# Deadlock

执行`./vector-deadlock -n 2 -l 1 -v`命令时，程序会创建2个线程，每个线程循环1次，每次将两个共享向量中的所有对应元素相加。参数的具体说明见[README](./README)。

记这两个向量为A和B，由于两个向量是全局共享的，因此每次操作向量的时候需要加锁。如果加上参数`-d`，那么程序就会用两把锁分别锁两个向量，且不同线程加锁的顺序刚好相反，这样就可能导致一个线程申请到了向量A的锁，另一个线程申请到了向量B的锁，然后双方都需要对方的锁，造成死锁。

经过实验，先将`VECTOR_SIZE`改为`1000000`，然后多次执行`./vector-deadlock -n 8 -l 10 -v -d`，就会出现死锁现象。事实上，`VECTOR_SIZE`越大，线程数量越多，循环次数越大，出现死锁的概率就越大。

死锁有四个必要条件：互斥，持有并等待，非抢占，循环等待。只要破坏其中一个条件，就可以避免死锁，代码提供了四种避免死锁的方案，分别破坏了四个条件中的其中一个。

`vector-nolock.c`：避免互斥。根本就没有锁，利用硬件支持的原子操作fetch-and-add进行元素相加，从而避免互斥。但其适用范围比较局限，现实中有很多复杂的互斥操作，不加锁是做不到的。

`vector-global-order.c`：避免循环等待。将资源排序，按全局顺序加锁，所有线程必须先锁下标小的向量，再锁大的，从而避免循环等待。

`vector-avoid-hold-and-wait.c`：避免持有并等待。搞一把全局大锁，所有线程必须先申请到全局锁，才能申请每个向量的锁，拿到向量锁就把全局锁释放掉，从而避免持有并等待。

`vector-try-wait.c`：避免非抢占。拿不到所有的锁就释放拿到的锁，从而避免非抢占。这种情况下，如果一个线程拿到了向量A的锁，另一个拿到了向量B的锁，那么必然有一个线程会释放自己的锁，另一个线程就能拿到所有的锁。也有可能两个线程都会释放自己的锁，但是概率相对比较小，从头再来一遍即可，总有一次会成功。
