# 高性能计算导论 PA3

> 2017011620  计73  李家昊

### 实现方法

根据参考方法（论文方法），实现了分块 Floyd-Warshall 算法，将邻接矩阵分为 $32\times 32$ 的方块，依次遍历每个中心块，对于每个中心块，分 3 阶段处理，每阶段对应一个 GPU 核函数。

阶段 1：在中心块内部执行 Floyd-Warshall 算法。分配 $1\times 1$ 个线程块，每个线程块分配 $32\times 32$ 线程，每个线程负责中心块中的一个元素。运行时，首先将该中心块从 Global Memory 拷贝到速度更快的 Shared Memory，线程同步后，执行 Floyd-Warshall 算法，每次迭代需要线程同步，最后拷贝回 Global Memory 即可。

阶段 2：在以中心块为中心的十字块上，用中心块的结果和十字块中原本的结果来更新十字块。记图的节点数量为 $n$，则中心块有 $b=\lceil n/32\rceil$ 个，分配 $b \times 2$ 个线程块，每个线程块分配 $32\times 32$ 线程，这 $2b$ 个线程块分别负责十字块的 $b$ 个行块和 $b$ 个列块，中心块对应的线程块直接返回。运行时，首先将中心块和当前块拷贝到 Shared Memory，线程同步后，执行 Floyd-Warshall 算法，每次迭代需要线程同步，最后拷贝回 Global Memory。

阶段 3：用十字块的结果更新剩余的块。分配 $b\times b$ 个线程块，每个线程块分配 $32\times 32$ 线程，每个线程块负责邻接矩阵的一个方块，十字块对应的进程块直接返回。运行时，将当前块依赖的行块和列块拷贝到 Shared Memory 中，线程同步后，执行 Floyd-Warshall 算法，注意当前块内每个元素可独立计算，互不依赖，因此迭代时无需线程同步，最后将结果拷贝回 Global Memory 即可。

### 实验结果

在 $n=1000,2500,5000,7500,10000$ 时的运行时间，及相对于助教提供的朴素实现的加速比，如下表所示。

| 图规模（n） | apspRef 运行时间（ms） | apsp 运行时间（ms） | 加速比 |
| ----------- | ---------------------- | ------------------- | ------ |
| 1000        | 13.511                 | 2.821               | 4.789  |
| 2500        | 376.889                | 28.150              | 13.389 |
| 5000        | 2970.642               | 209.597             | 14.173 |
| 7500        | 10012.554              | 693.668             | 14.434 |
| 10000       | 22616.691              | 1632.830            | 13.851 |

### 参考资料

+ Katz, G. J., & Kider, J. T. (2008). All-pairs shortest-paths for large graphs on the GPU.

